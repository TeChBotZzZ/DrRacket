#lang racket
(define env '())

(define (lookup varName env)
  (cond ((null? env) (error "Unbound variable" varName))
        ((eq? varName (caar env)) (cdar env))
        (else (lookup varName (cdr env)))))

(define (intVal varName val)
  (set! env (cons (cons varName val) env))
  val)

(define (eval-exp exp env)
  (cond ((number? exp) exp)
        ((symbol? exp) (lookup exp env))
        ((eq? 'expt (car exp))
         (expt (eval-exp (cadr exp) env)
               (eval-exp (caddr exp) env)))
        ((eq? '+ (car exp))
         (apply + (map (lambda (exp) (eval-exp exp env))
                       (cdr exp))))
        ((eq? '- (car exp))
         (apply - (map (lambda (exp) (eval-exp exp env))
                       (cdr exp))))
        ((eq? '* (car exp))
         (apply * (map (lambda (exp) (eval-exp exp env))
                       (cdr exp))))
        ((eq? '/ (car exp))
         (apply / (map (lambda (exp) (eval-exp exp env))
                       (cdr exp))))
        ((eq? 'intVal (car exp))
         (intVal (cadr exp) (eval-exp (caddr exp) env)))
        (else (error "Unknown operator" (car exp)))))


(define (interpreter env)
  (display "Scheme> ")
  (let ((input (read)))
    (let ((result (eval-exp input env)))
      (display result)
      (newline)))
  (interpreter env))

(interpreter env)
